# API description and notes

## Core `module` API

The `module` API was chosen such that the API names have a declarative feel, to
indicate these are used for static, declarative tracing of dependencies.

Since an API is used it allows the equivalent of import expressions. This has
been useful in AMD and node code to reduce the amount of code needed to use a
dependency.

However, since the API has a declarative feel to it, it will help set
expectations that all dependencies are fetched and executed, and expression
evaluation does not affect that fetching and execution.

### import and export

The module system parses the text of a module for module API use, then loads and
executes dependencies before executing the module.

Dependencies are specified by using `module(StringLiteral)`. A module sets the
export using `module.export = value`, where `value` is the export value.
It must be set before the end of the module body execution.

Alternatively, module.export is originally set to an empty object, which can
be used to attach properties for the export value,
`module.export.route = function() {}`.

```javascript
// A module that depends on two other modules
var { paint } = module('brush');
var pixelate = module('pixelate');

var someData = {};

pixelate(someData);

module.export = {
  paint: paint,
  pixelate: pixelate
};
```

### Multiple, local modules

Multiple modules can be inlined in a file by using `module.define`, where
the module body is stored in a function.

```javascript
module.define('colorize', function(module) {
  module.export = function colorize() {};
});

module.define('blur', function(module) {
  module.export = function blur() {};
});

module.define('effects', function(module) {
  module.export = {
    colorize: module('colorize'),
    blur: module('blur')
  };
});
```

For files that contain one module, `module.define` is not used, but the loader
can conceptually treat this as executing a `module.define` with the contents
of the file as the body of the factory function passed to `module.define`.

Each module gets its own instance of `module` that is customized to that
module.

`module.define` modules can be nested, and the nested modules are only visible
to each other on the same level, and to the module containing them.

However, given the async resolution of dependencies (even local modules could
need dynamically loaded dependencies), `module(StringLiteral)` in the same
module cannot be used to grab a local module and use it in its export.

Instead, there should be a local module that does a `module.define()` to set up
the desired export, and `module.exportDefine()` should be used to
specify the factory function that will give the final module value.

```javascript
module.define('colorize', function(module) {
  module.export = function colorize() {};
});

module.define('blur', function(module) {
  module.export = function blur() {};
});

module.define('effects', function(module) {
  module.export = {
    colorize: module('colorize'),
    blur: module('blur')
  };
});

// THE FOLLOWING COMMENTED OUT CODE WOULD FAIL because
// 'effects' may not be available yet, and 'effects' is
// only fully resolved once it is part of an active
// dependency tree.
// var effects = module('effects');
// var $ = module('jquery');

// THIS WILL WORK, since this factory function can be called once
// all dependencies are met.
module.exportDefine(function(module) {
  var effects = module('effects');
  var $ = module('jquery');
  module.export = function applyEffectsToDom(selector) {
    return effects.colorize(effects.blur($(selector)[0]));
  };
});
```

If a module does not need a local module for immediate module export, then
`module.exportDefine` does not need to be used.

Additionally, if this is not a module body, but just a script in an HTML script
tag, `module.use()` can be used to get access to these local modules.

When a module is not present at the immediate module's loader level, it is
searched for up the chain of nested module loader instances. If it is not
available in any of the parents, the topmost loader will dynamically load it.

### `module.use`

`module.use()` allows dynamically using any modules that may or may not be
loaded. This will most commonly be used in web pages to start module loading,
but could also be used inside a module for dependencies that are only known
at runtime.

It takes a list of modules and a callback function. It returns a Promise.
The success promise value is an array of module exports, but the callback
function receives them as individual callback arguments. The promise returned
will hold any error generated by the callback function, if one is generated.

```javascript
module.use('a', 'b', function(a, b) {
})
.catch(function(error) {
});

```

## Concerns about existing `module` use in JS

While `module` is used today, notably in CommonJS/Node and AMD
module systems, that object is a second-tier object, and it appears as an
object and not a function. Script detection for those module systems usually
use `require`, `exports` and `define` for choosing what module system to invoke.

So it should be possible to use `module` without too much trouble. However,
a configuration option on the `module` loader could be provided to instruct the
loader to not provide a wrapping for its `module` object if a script was wanting
to use `module` in a different fashion.

In summary, the benefits of an API approach and the terse, declarative feel of
using `module('id')` are larger benefits than trying to avoid `module`.

## Library construction

The important implementation part is in **parts/m.js**. **parts/build.js**
builds **module.js** which can run in a modern browser. Latest versions of
Firefox, Chrome, Safari have all been tried and work.

Tests are run by opening **test/index.html** in a modern web browser.

On the implementation, it is just meant for illustration, to prove out the
concepts via tests, and not considered production worthy. Most notably, it just
uses a underscore-prefixed convention to indicate private properties. This is
just done for ease of implementation and introspection while debugging. However,
a real implementation would do fancier things to hide those details.

[esprima](http://esprima.org/) is used to parse the module text, so the JS
support in this implementation is limited to the support provided by esprima. I
would like to switch to using the sweetjs reader in the future, as it would
allow more flexibility in the level of JS support.

[prim](https://github.com/requirejs/prim) is used for promise support. It passes
the a+ promises 2.0.4 tests.

## Scratchpad

This section is just a collection of notes/todos, just for repo developer use.

Tests to write:

* return a promise for a module value, make sure that works, promise unwrapping not in the way.
* return a promise for a exportDefine case too, promise unwrapping not in the way.
* test that uses local modules top level and module.use().
* test interop with normal scripts that do globals.

Notes

* I prefer `return` to set module export, instead of module.export, as it more correctly enforces "end of factory function means export is considered set" but right now JS grammar does not consider a top level `return` as valid.

TODOS:

* doc 'use strict' default.

* Test for loading just a set of named module.define modules

* Test for loading a module with just a module.exportDefine, how dependencies work in that case. Should work, just need test in place to verify against future changes.

* declarative config easier for tools to read, for autocomplete. add in loader.config() for top level module objects only, using AMD-inspired config as baseline. Accessible via module.top.config();

* When config is in: update qunit example for an override of module wrapping. Also for strict settings.

* Error APIs giving URLs to descriptions of how to fix. Use first for cycles.

* examples of using real libraries today, Backbone, fs, underscore.

* loader.introspect(function(on) {
  on('defined', function(module) {});
});

* new module.Loader({
  constrain: true,

  whitelist: {
    top: true,
    config: true,
  }
});


* create new module.Loader(), ability to reuse config from another loader. Also, be able to reuse module table? No, explicit population can be done by iterating and adding what is needed. Need iteration and event (when added) apis, security mode.

* specify module.uri for nested module, plus relative module IDs,
for it.

* Wire up waitInterval timeouts. Call reject on specific modules. Allow for a reset/remapping via paths array config in requirejs? Does the DepResolver now help with that indirection?

* Hmm, will AMD-style loader plugins really work with existing ModuleLoader API? AMD plugin load() method right now allows fetching some dependencies to finish loading of the resource. These can get associated with the load for that resource, to allow cycle breaking, in AMD systems. Does that hold together here?

* Store exportDefine factory in a special slot instead of using a special name.

* Generate useful errors with codes that can be looked up for fix advice.

* a "debug" mode that allows printing out dependency tree as a data structure?

* How best to do load cleanups. Given async nature, and code could grab a reference to a load in the middle of something like the pipeline that survives across async calls, need to cautious about cleaning up. Maybe it is enough to do it once all module loading has been known to complete for the current cycle, since the module cache would be warm by then.
