# Examples

## Export

Two ways to export a module value: assign to `module.export` or attach properties to a basic object provided by `module.export`.

Assignment:

```javascript
// In a module with ID of 'speak'
module.export = function speak(message) {
  console.log(message);
}
```

Attach properties:

```javascript
// In a module with ID of 'calc'
module.export.add = function (a, b) { return a + b; },
module.export.subtract = function (a, b) { return a - b; },

```

## Referencing dependencies

Dependencies are indicated by the use of `module(StringLiteral)`. The module loader will statically parse out those dependencies, fetch and execute them, then execute the current module body.

Export values are just regular JavaScript objects, so any variable assignment or expression supported by the language works. These are all valid ways to depend on the 'speak' and 'calc' modules defined in the [Export](#export) section:

For exports that are functions:

```javascript
var speak = module('speak');
speak('hello');
```

For exports that have multiple properties:

```javascript
var calc = module('calc');
calc.add(1, 2);

// or
var add = module.('calc').add;
add(1, 2);
```

If the JS engine supports ES6 destructuring:

```javascript
var { add, subtract } = module('calc');
add(1, 2);
subtract(5, 3);
```

### Dynamic references

If dynamically choosing what module to use:

```javascript
var moduleId = 'speak';
if (someCondition) {
  moduleId = 'speak2';
}

module.use(moduleId, function(speak) {
  speak('hello');
}).catch(function(err) {
  // Do something with the error here
});
```

### Inlining modules

Modules may be inlined by just adding this kind of function wrapper around the module:

```javascript
module.define('moduleId', function(module) {
  // module body here
});
```

[Nested definitions](https://github.com/jrburke/module/blob/master/docs/api.md#multiple-local-modules) to construct a module from a set of internal, locally visible modules is also supported.

This inlining form should usually only be generated by build tools, or at the top level of a loader instance creation, to set up some default entries in the loader. It should not be needed for module sources that are in individual files.
